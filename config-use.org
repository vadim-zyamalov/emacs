#+TITLE: Настройки Emacs, основанные на Org-mode
#+LANGUAGE: ru
#+PROPERTY: header-args :results silent

В данном файле представлены настройки =Emacs=, подгружаемые при помощи =Org-babel=. Все блоки кода при загрузке Emacs автоматически извлекаются и исполняются.

Это моя вторая попытка оформления настроек для Emacs при помощи =Org-mode=. Первая попытка вылилась в абсолютно нечитаемый файл, выглядящий как `тарелка спагетти`.

* Содержание :toc:github:
- [[#важно][Важно!]]
- [[#базовые-файлы][Базовые файлы]]
- [[#настройки-use-package][Настройки =use-package=]]
- [[#общие-настройки][Общие настройки]]
  - [[#сохранение-истории-команд-и-позиций][Сохранение истории команд и позиций]]
  - [[#ускорение-запуска-emacs][Ускорение запуска =Emacs=]]
  - [[#убираем-мусор][Убираем мусор]]
  - [[#работа-с-файлами][Работа с файлами]]
- [[#настройки-пользовательского-интерфейса][Настройки пользовательского интерфейса]]
  - [[#вкладки][Вкладки]]
  - [[#статусная-строка][Статусная строка]]
  - [[#стартовый-экран][Стартовый экран]]
  - [[#отображение-строк][Отображение строк]]
  - [[#отображение-окон][Отображение окон]]
  - [[#дерево-каталогов-проекта][Дерево каталогов проекта]]
  - [[#украшательства][Украшательства]]
- [[#настройки-справки][Настройки справки]]
- [[#настройки-ввода][Настройки ввода]]
  - [[#мышь][Мышь]]
  - [[#клавиатура][Клавиатура]]
- [[#настройки-редактирования][Настройки редактирования]]
  - [[#настройки-сохранения][Настройки сохранения]]
  - [[#настройки-отступов][Настройки отступов]]
  - [[#настройки-отмены-и-повтора][Настройки отмены и повтора]]
  - [[#настройки-отражения-скобок][Настройки отражения скобок]]
  - [[#настройки-комментирования][Настройки комментирования]]
  - [[#настройки-замены][Настройки замены]]
  - [[#полезные-команды][Полезные команды]]
- [[#настройки-автодополнения][Настройки автодополнения]]
  - [[#вспомогательные-функции][Вспомогательные функции]]
  - [[#lsp][LSP]]
  - [[#corfu-или-company][=Corfu= или =Company=]]
  - [[#vertico-consult-и-embark-или-ivy][=Vertico=, =Consult= и =Embark= или =Ivy=]]
  - [[#сниппеты][Сниппеты]]
- [[#настройки-для-языков-программирования][Настройки для языков программирования]]
  - [[#markdown][Markdown]]
  - [[#org-mode][Org-mode]]
  - [[#ess][ESS]]
  - [[#python][Python]]
  - [[#js][JS]]
  - [[#lua][Lua]]
  - [[#latex][LaTeX]]

* Важно!

Для нормальной работы нативной компиляции _нужна_ библиотека =libgccjit=. В Windows проще установить библиотеку через MSYS2:

#+begin_src shell :tangle no
pacman -S mingw-w64-i686-libgccjit
#+end_src

* Базовые файлы

=Emacs= для загрузки требует наличия файла настроек =init.el=, из которого загружаются все необходимые настройки. Я, вслед за многими пользователями, использую данный файл для загрузки org-документа с конфигурацией.
Помимо настоящего файла настроек, =Emacs= требует наличия файла =init.el= для загрузки, =init.el= нужен для загрузки данного файла.

#+include: early-init.el src emacs-lisp

#+include: init.el src emacs-lisp

* Настройки =use-package=

Установка [[https://github.com/jwiegley/use-package][use-package]] для дальнейшей настройки =Emacs=. В =Emacs 29= use-package встроен, так что устанавливать его не нужно.

#+begin_src emacs-lisp
(when (< emacs-major-version 29)
    (straight-use-package 'use-package))

(require 'use-package)

(use-package use-package-hydra
    :straight t)
#+end_src

* Общие настройки

Организуем вспомогательные константы, показывающие факт запуска =Emacs= в Windows или в 64-битной системе. Они нужны будут в дальнейшем для условной установки пакетов.

#+begin_src emacs-lisp
(defconst ensure/is64
    (not (null
          (string-match "^x86_64-.*" system-configuration)))
    "Equals t if Emacs works on 64-bit system.")

(defconst ensure/isWindows
    (memq system-type '(cygwin windows-nt ms-dos))
    "Equals t if Emacs works on Windows host system.")
#+end_src

Заставляем =Emacs= использовать =utf-8= как стандартную кодовую таблицу.

#+begin_src emacs-lisp
(set-language-environment 'utf-8)
(setq locale-coding-system 'utf-8)
(set-default-coding-systems 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-selection-coding-system
 (if (eq system-type 'windows-nt)
         'utf-16-le
     'utf-8))
(prefer-coding-system 'utf-8)
#+end_src

=Emacs= по умолчанию требует длинные ответы на вопросы (=yes= и =no=). Следующие настройки позволяют ограничиться одной буквой (=y= и =n=).

#+begin_src emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
(setq confirm-kill-emacs 'y-or-n-p)
#+end_src

Следовать ли автоматически по символьным ссылкам.

#+begin_src emacs-lisp
(setq vc-follow-symlinks t)
#+end_src

** Сохранение истории команд и позиций

=saveplace= --- встроенный пакет, позволяющий сохранять позицию в редактируемых файлах. При повторном открытии курсор (=point=) будет автоматически размещен в сохраненной позиции.

#+begin_src emacs-lisp
(use-package saveplace
    :init
    (setq save-place-file (expand-file-name
                           (format "%s/var/%s"
                                   user-emacs-directory
                                   "save-place.el")))
    :config
    (save-place-mode 1))
#+end_src

=savehist= --- другой встроенный пакет, сохраняющий историю введенных команд между сессиями. По умолчанию =Emacs= сохраняет историю *только* в пределах текущей сессии.

#+begin_src emacs-lisp
(use-package savehist
    :init
    (setq savehist-file (expand-file-name
                    (format "%s/data/%s"
                            user-emacs-directory
                            "savehist.el")))
    :config
    (setq history-delete-duplicates t
          history-length 25)
    (savehist-mode))
#+end_src

** Ускорение запуска =Emacs=

В файле =early-init.el= для ускорения запуска было задано очень большое пороговое значение для запуска сборщика мусора, чтобы предотвратить его запуск в процессе старта сессии. Также был обнулен =file-name-handler-alist=. Приведенный ниже хук запускается в конце инициализации, в результате чего пороговое значение устанавливается на более-менее адекватном уровне, а =file-name-handler-alist= --- восстанавливается.

#+begin_src emacs-lisp
(add-hook 'emacs-startup-hook (lambda ()
                                  (setq gc-cons-threshold (* 8 1024 1024))
                                  (setq file-name-handler-alist file-name-handler-alist-original)
                                  (makunbound 'file-name-handler-alist-original)))
#+end_src

Установка пакета для настройки работы сборщика мусора. В Windows он вызывает периодическое подвисание =Emacs=. Судя по всему, =Emacs= в Windows однопоточен, что и приводит к такому эффекту.

#+begin_src emacs-lisp
(use-package gcmh
    :straight t
    :config
    (gcmh-mode t)
    :custom
    (gcmh-verbose t)
    (gcmh-low-cons-threshold (* 8 1024 1024)))
#+end_src

** Убираем мусор

Устанавливаем пакт =no-littering=, блокирующий замусоривание рабочих папок временными файлами.

#+begin_src emacs-lisp
(use-package no-littering
    :straight t
    :after savehist
    :init
    (setq no-littering-etc-directory
          (expand-file-name "config/" user-emacs-directory))
    (setq no-littering-var-directory
          (expand-file-name "data/" user-emacs-directory)))
#+end_src

Запретить =Emacs= создавать блокирующие файлы.

#+begin_src emacs-lisp
(setq create-lockfiles nil)
#+end_src

Сохранять бэкапы не в папке с файлами!

#+begin_src emacs-lisp
(setq backup-directory-alist `(("." . "~/.saves"))
      backup-by-copying-when-linked t)
#+end_src

** Работа с файлами

Следующий хук запускается перед сохранением файлов, обеспечивая создание несуществующих каталогов в пути сохраняемого файла.

#+begin_src emacs-lisp
(add-hook 'before-save-hook
          (lambda ()
              (when buffer-file-name
                  (let ((dir (file-name-directory buffer-file-name)))
                      (when (and (not (file-exists-p dir))
                                 (y-or-n-p (format "Directory %s does not exist. Create it? " dir)))
                          (make-directory dir t))))))
#+end_src

Следующий хук полезен в Linux, он дает сохраняемому файлу скрипта право на исполнение. В Windows это бесполезно.

#+begin_src emacs-lisp
(unless ensure/isWindows
    (add-hook 'after-save-hook 'executable-make-buffer-file-executable-if-script-p))
#+end_src

Настраиваем рекурсивное удаление директорий в =dired=.

#+begin_src emacs-lisp
(use-package dired
    :init
    (setq dired-recursive-deletes 'top))
#+end_src

* Настройки пользовательского интерфейса

=Emacs= настроен на изменение размера фрейма (окна, в традиционной терминологии оконных менеджеров) пропорционально размеру символа. В оконных менеджерах это может быть неудобно и некрасиво. Следующие настройки заставляют =Emacs= изменять размер фрейма произвольно.

Также автоматически разворачиваем окно при запуске.

#+begin_src emacs-lisp
(setq frame-resize-pixelwise t)
(add-to-list 'default-frame-alist '(fullscreen . maximized))
#+end_src

Задаем пороговое значение для автоматического разбиения окон по вертикали. Если ширина фрейма менее 80 символов, то будет применено горизонтальное разбиение.

#+begin_src emacs-lisp
(setq split-width-threshold 80)
#+end_src

Лично мне не нравится стандартный прямоугольный курсор, черта, на мой взгляд, удобнее.

#+begin_src emacs-lisp
(setq-default cursor-type 'bar)
#+end_src

** Вкладки

Ранее я использовал сторонние пакеты для отображения вкладок, то потом узнал, что аналогичная функциональность встроена в =Emacs=: [[https://www.emacswiki.org/emacs/TabBarMode][TabBarMode]]. Да, эти вкладки не такие красивые, как сторонние, но мне хватает.

| Клавиша   | Карта  | Команда         | Действие                         |
|-----------+--------+-----------------+----------------------------------|
| =M-<left>=  | global | previous-buffer | Переключение на предыдущий буфер |
| =M-<right>= | global | next-buffer     | Переключение на следующий буфер  |

#+begin_src emacs-lisp
(use-package tab-line
    :demand t
    :bind (("M-<left>" . previous-buffer)
           ("M-<right>" . next-buffer))
    :config
    (global-tab-line-mode t))
#+end_src

** Статусная строка

А вот статусную строку я поменял. Как ни странно, стандартная не в полной мере соответствовала моим представлениям о минимализме, так что я остановился на [[https://github.com/seagle0128/doom-modeline][Doom Modeline]].

#+begin_src emacs-lisp
(use-package doom-modeline
    :straight t
    :hook (after-init . doom-modeline-mode)
    :custom
    (doom-modeline-height 24)
    (doom-modeline-minor-modes t))
#+end_src

Также я установил пакет [[https://github.com/tarsius/minions][Minions]], который заменяет довольно неопрятный список второстепенных режимов на аккуратный смайлик (строго говоря на =;-=, но получается смайлик). В Doom Modeline при загрузке этого пакета опциональный список второстепенных режимов заменяется на кнопку с шестеренкой (а не смайликом).

#+begin_src emacs-lisp
(use-package minions
    :straight t
    :config
    (minions-mode t))
#+end_src

А это просто [[https://github.com/TeMPOraL/nyan-mode][нотка безумия]], которая, конечно, не сильно соотносится с моей тягой к минимализму...

#+begin_src emacs-lisp
(use-package nyan-mode
    :straight t
    :config
    (nyan-mode))
#+end_src

** Стартовый экран

Красивый [[https://github.com/emacs-dashboard/emacs-dashboard][стартовый экран]]. Очень удобный, к слову. Показывает ссылки на последние файлы и проекты, плюс я вывел ссылки на файлы и репозиторий настроек =Emacs=.

#+begin_src emacs-lisp
(use-package dashboard
    :straight t
    :after (nerd-icons)
    :config
    (dashboard-setup-startup-hook)
    :custom
    (dashboard-display-icons-p t)
    (dashboard-icon-type 'nerd-icons)
    (dashboard-set-heading-icons t)
    (dashboard-set-file-icons t)
    (dashboard-items '((recents . 15)
                       (projects . 5)))
    (dashboard-startup-banner (expand-file-name
                               "emacs.png"
                               (file-name-directory user-init-file)))
    (dashboard-set-navigator t)
    (dashboard-navigator-buttons
     `((
        (,(nerd-icons-sucicon "nf-custom-emacs" :height 1.0 :v-adjust 0.0)
         "Настройки"
         "Открыть файл с настройками (init.el)"
         (lambda (&rest _)
             (find-file user-init-file)))
        (,(nerd-icons-faicon "nf-fa-github" :height 1.0 :v-adjust 0.0)
         "dotfiles"
         "Github с конфигурационными файлами"
         (lambda (&rest _) (browse-url "https://github.com/d9d6ka/dotfiles")))
        (,(nerd-icons-faicon "nf-fa-github" :height 1.0 :v-adjust 0.0)
         "emacs"
         "Github с настройками Emacs"
         (lambda (&rest _) (browse-url "https://github.com/d9d6ka/emacs")))
        ))))
#+end_src

** Отображение строк

Vim умеет красиво отображать номер текущей строки и относительные номера соседних строк. =Emacs= тоже так умеет. Это имеет смысл для поклонников =Evil Mode=, так как облегчает перемещение между строками, но и просто так тоже красиво.

#+begin_src emacs-lisp
(setq display-line-numbers-type 'relative)
(global-display-line-numbers-mode)
#+end_src

Просим показывать нам аккуратные стрелочки на границе *визуально* разбитой и перенесенной строки.

#+begin_src emacs-lisp
(setq visual-line-fringe-indicators '(left-curly-arrow right-curly-arrow))
(global-visual-line-mode t)
#+end_src

Очень полезный пакет [[https://gitlab.com/protesilaos/pulsar][pulsar]]. Он визуально подсвечивает текущую строку при наступлении некоторого события, например, при смене окна. Это облегчает работу, так как позволяет не искать курсор по всему экрану.

#+begin_src emacs-lisp
(use-package pulsar
    :straight t
    :config
    (pulsar-global-mode t)
    :custom
    (pulsar-pulse t)
    (pulsar-delay 0.055)
    (pulsar-pulse-functions '(recenter-top-bottom
                              move-to-window-line-top-bottom
                              reposition-window
                              bookmark-jump
                              other-window
                              delete-window
                              delete-other-windows
                              forward-page
                              backward-page
                              scroll-up-command
                              scroll-down-command
                              windmove-right
                              windmove-left
                              windmove-up
                              windmove-down
                              windmove-swap-states-right
                              windmove-swap-states-left
                              windmove-swap-states-up
                              windmove-swap-states-down
                              tab-new
                              tab-close
                              tab-next
                              org-next-visible-heading
                              org-previous-visible-heading
                              org-forward-heading-same-level
                              org-backward-heading-same-level
                              outline-backward-same-level
                              outline-forward-same-level
                              outline-next-visible-heading
                              outline-previous-visible-heading
                              outline-up-heading
                              ctrlf-forward-default
                              ctrlf-backward-default
                              ctrlf-forward-alternate
                              ctrlf-backward-alternate
                              ctrlf-forward-symbol
                              ctrlf-forward-symbol-at-point
                              consult-line)))
#+end_src

** Отображение окон

Иногда во фрейма =Emacs= мы имеем несколько окон. Пакет [[https://github.com/cyrus-and/zoom][zoom]] автоматически изменяет размеры окон так, чтобы активное имело нужный размер.

#+begin_src emacs-lisp :tangle no
(use-package zoom
    :straight t
    :config
    (zoom-mode)
    :custom
    (zoom-size '(0.618 . 0.618))
    (zoom-ignored-major-modes '(ess-r-mode
                                inferior-ess-r-mode
                                ess-rdired-mode))
    (zoom-ignored-buffer-names '("*R*"
                                 "*R dired*"
                                 "*R view*")))
#+end_src

Другой пакет, [[https://github.com/gonewest818/dimmer.el][dimmer]], делает неактивные окна более тусклыми, что дополнительно вызуально выделяет активное.

#+begin_src emacs-lisp
(use-package dimmer
    :straight t
    :config
    (dimmer-configure-which-key)
    (add-to-list 'dimmer-buffer-exclusion-regexps "^.*\\*corfu\\*.*$")
    (add-to-list 'dimmer-buffer-exclusion-regexps "^.*\\*corfu-popupinfo\\*.*$")
    (dimmer-mode t)
    :custom
    (dimmer-fraction 0.6)
    (dimmer-watch-frame-focus-events nil))
#+end_src

Пакет [[https://www.emacswiki.org/emacs/download/framemove.el][framemove]], конечно, не связан с отображением активных окон напрямую, но позволяет удобно их менять. Строго говоря, пакет расширяет встроенный функционал перемещения между окнами *windmove*, позволяя перемещаться между фреймами. Пока не использую.

| Карта      | Клавиша | Команда        | Действие                    |
|------------+---------+----------------+-----------------------------|
| global     | =<f6>=    |                | Вход в тело "гидры"         |
| hydra-wind | =<left>=  | windmove-left  | Переход в окно/фрейм слева  |
| hydra-wind | =<right>= | windmove-right | Переход в окно/фрейм справа |
| hydra-wind | =<up>=    | windmove-up    | Переход в окно/фрейм сверху |
| hydra-wind | =<down>=  | windmove-down  | Переход в окно/фрейм снизу  |

#+begin_src emacs-lisp
(use-package framemove
    :straight t
    :after (hydra)
    :bind ("<f6>" . hydra-wind/body)
    :hydra (hydra-wind ()
                       "Moving between windows."
                       ("<left>"  windmove-left  "left")
                       ("<right>" windmove-right "right")
                       ("<up>"    windmove-up    "up")
                       ("<down>"  windmove-down  "down"))
    :custom
    (framemove-hook-into-windmove t))
#+end_src

Пакет [[https://github.com/abo-abo/ace-window][Ace Window]] делает то же, что и =framemove=, но немного иначе. Если во фрейме всего два окна, то вызов команды =ace-window= приводит к переключению между окнами. Если больше, то на каждом окне появляется некое значение (по умолчанию от 1 до 9). При нажатии на соответствующую клавишу осуществляется переход в это окно.

| Клавиша     | Карта  | Команда    | Действие                                               |
|-------------+--------+------------+--------------------------------------------------------|
| =M-o=         | global | ace-window | Переключение между окнами                              |
| =C-u M-o=     | global |            | Поменять текущее окно местами с выбранным (или другим) |
| =C-u C-u M-o= | global |            | Удалить выбранное окно (или другое)                    |

#+begin_src emacs-lisp
(use-package ace-window
    :straight t
    :bind (("M-o" . ace-window)))
#+end_src

** TODO Дерево каталогов проекта

Достаточно удобное [[https://github.com/jaypei/emacs-neotree][дерево каталогов]] текущего проекта, позволяющее, помимо переключения между файлами, производить несложные операции с ними.

| Клавиша | Карта  | Команда        | Действие              |
|---------+--------+----------------+-----------------------|
| =C-x t t= | global | neotree-toggle | Показ/скрытие NeoTree |

#+begin_src emacs-lisp :tangle no
(use-package neotree
    :straight t
    :bind (("C-x t t" . neotree-toggle))
    :custom
    (neo-smart-open t)
    (neo-window-width 40)
    (neo-theme (if (display-graphic-p) 'icons 'arrow)))
#+end_src

Еще одно удобное [[https://github.com/Alexander-Miller/treemacs/][дерево]], ориентированное на работу с проектами: по умолчанию в нем нужно загрузить нужные папки/проекты, между которыми можно быстро переключаться. Так как мне такая функциональность не нужна, то я настроил его на показ дерева *текущего* проекта.

| Клавиша   | Карта  | Команда                       | Действие                                                                                    |
|-----------+--------+-------------------------------+---------------------------------------------------------------------------------------------|
| =C-x t t=   | global | treemacs                      | Запуск treemacs                                                                             |
| =M-0=       | global | treemacs-select-window        | Либо запуск treemacs, либо вызов его окна, либо переключение между treemcs и другими окнами |
| =C-x t 1=   | global | treemacs-delete-other-windows | Закрытие других окон с сохранением окна treemacs                                            |
| =C-x t d=   | global | treemacs-select-directory     | Добавление в treemacs новой корневой папки                                                  |
| =C-x t C-t= | global | treemacs-find-file            | Поиск файла в дереве в окне treemacs                                                        |
| =C-x t M-t= | global | treemacs-find-tag             | Поиск тега в дереве в окне treemacs                                                         |

#+Begin_src emacs-lisp
(use-package treemacs
    :straight t
    :defer t
    :bind (("M-0"       . treemacs-select-window)
           ("C-x t 1"   . treemacs-delete-other-windows)
           ("C-x t t"   . treemacs)
           ("C-x t d"   . treemacs-select-directory)
           ("C-x t B"   . treemacs-bookmark)
           ("C-x t C-t" . treemacs-find-file)
           ("C-x t M-t" . treemacs-find-tag))
    :config
    (treemacs-fringe-indicator-mode 'always)
    (treemacs-follow-mode t)
    (treemacs-filewatch-mode t)
    (treemacs-project-follow-mode t)
    (pcase (cons (not (null (executable-find "git")))
                 (not (null treemacs-python-executable)))
        (`(t . t)
         (treemacs-git-mode 'deferred))
        (`(t . _)
         (treemacs-git-mode 'simple))))

(use-package treemacs-magit
    :straight t
    :after (treemacs magit))

(use-package treemacs-nerd-icons
    :straight t
    :after (treemacs nerd-icons)
    :config
    (treemacs-load-theme "nerd-icons"))
#+end_src

** Украшательства

*** Темы

До этого я пользовался Doom Palenight из [[https://github.com/doomemacs/themes][набора тем]] для DoomEmacs.

#+begin_src emacs-lisp :tangle no
(use-package doom-themes
    :straight t
    :config
    (doom-themes-visual-bell-config)
    (doom-themes-neotree-config)
    (doom-themes-org-config)
    (load-theme 'doom-palenight t)
    :custom
    (doom-themes-enable-bold t)
    (doom-themes-enable-italic t))

(use-package solaire-mode
    :straight t
    :config
    (solaire-global-mode t))
#+end_src

Потом использовал [[https://protesilaos.com/emacs/modus-themes][темы Modus]], отличающиеся повышенной контрастностью.

#+begin_src emacs-lisp :tangle no
(use-package modus-themes
    :straight t
    :config
    (load-theme 'modus-vivendi-tinted :no-confirm)
    :custom
    (modus-themes-bold-constructs t)
    (modus-themes-italic-constructs t)
    (modus-themes-common-palette-overrides '((border-mode-line-active unspecified)
                                             (border-mode-line-inactive unspecified))))
#+end_src

И еще тестирую [[https://protesilaos.com/emacs/ef-themes][Ef-themes]] от автора тем [[https://protesilaos.com/emacs/modus-themes][Modus]].

#+begin_src emacs-lisp
(use-package ef-themes
    :straight t
    :init
    (mapc #'disable-theme custom-enabled-themes)
    :config
    (load-theme 'ef-autumn :no-confirm))
#+end_src

*** Шрифты

Настроим стандартный шрифт. Я предпочитаю [[https://github.com/JetBrains/JetBrainsMono][JetBrains Mono]], хотя это дело вкуса. Некоторое время использовал [[https://github.com/tonsky/FiraCode][Fira Code]]; сейчас буду использовать [[https://github.com/be5invis/Iosevka][Iosevka]].

#+begin_src emacs-lisp
(cond ((find-font (font-spec :name "Iosevka"))
       (set-face-attribute 'default
                           nil
                           :font "Iosevka"
                           :height 120))
      ((find-font (font-spec :name "Fira Code"))
       (set-face-attribute 'default
                           nil
                           :font "Fira Code"
                           :height 120))
      ((find-font (font-spec :name "JetBrains Mono"))
       (set-face-attribute 'default
                           nil
                           :font "JetBrains Mono"
                           :height 120)))
#+end_src

А вот вледующий пакет не будет работать в версиях =Emacs= старше 28.1 из-за ошибки, фатальной для работы пакета. Он добавляет поддержку [[https://github.com/mickeynp/ligature.el][лигатур]], разумеется, если шрифт их поддерживает. Ранее этот пакет отсутствовал в основных репозиториях, поэтому я устанавливаю его из репозитория напрямую.

#+begin_src emacs-lisp :noweb no
(unless (version< emacs-version "28.1")
    (use-package ligature
        :straight (ligature :type git :host github :repo "mickeynp/ligature.el")
        :config
        (ligature-set-ligatures
         'prog-mode
         (pcase (face-attribute 'default :family)
             ("JetBrains Mono"
              '("-|" "-~" "---" "-<<" "-<" "--" "->" "->>" "-->" "///" "/=" "/=="
                "/>" "//" "/*" "*>" "***" "*/" "<-" "<<-" "<=>" "<=" "<|" "<||"
                "<|||" "<|>" "<:" "<>" "<-<" "<<<" "<==" "<<=" "<=<" "<==>" "<-|"
                "<<" "<~>" "<=|" "<~~" "<~" "<$>" "<$" "<+>" "<+" "</>" "</" "<*"
                "<*>" "<->" "<!--" ":>" ":<" ":::" "::" ":?" ":?>" ":=" "::=" "=>>"
                "==>" "=/=" "=!=" "=>" "===" "=:=" "==" "!==" "!!" "!=" ">]" ">:"
                ">>-" ">>=" ">=>" ">>>" ">-" ">=" "&&&" "&&" "|||>" "||>" "|>" "|]"
                "|}" "|=>" "|->" "|=" "||-" "|-" "||=" "||" ".." ".?" ".=" ".-" "..<"
                "..." "+++" "+>" "++" "[||]" "[<" "[|" "{|" "??" "?." "?=" "?:" "##"
                "###" "####" "#[" "#{" "#=" "#!" "#:" "#_(" "#_" "#?" "#(" ";;" "_|_"
                "__" "~~" "~~>" "~>" "~-" "~@" "$>" "^=" "]#"))
             ((or "Fira Code" "Cascadia Code")
              '("|||>" "<|||" "<==>" "<!--" "####" "~~>" "***" "||=" "||>"
                ":::" "::=" "=:=" "===" "==>" "=!=" "=>>" "=<<" "=/=" "!=="
                "!!." ">=>" ">>=" ">>>" ">>-" ">->" "->>" "-->" "---" "-<<"
                "<~~" "<~>" "<*>" "<||" "<|>" "<$>" "<==" "<=>" "<=<" "<->"
                "<--" "<-<" "<<=" "<<-" "<<<" "<+>" "</>" "###" "#_(" "..<"
                "..." "+++" "/==" "///" "_|_" "www" "&&" "^=" "~~" "~@" "~="
                "~>" "~-" "**" "*>" "*/" "||" "|}" "|]" "|=" "|>" "|-" "{|"
                "[|" "]#" "::" ":=" ":>" ":<" "$>" "==" "=>" "!=" "!!" ">:"
                ">=" ">>" ">-" "-~" "-|" "->" "--" "-<" "<~" "<*" "<|" "<:"
                "<$" "<=" "<>" "<-" "<<" "<+" "</" "#{" "#[" "#:" "#=" "#!"
                "##" "#(" "#?" "#_" "%%" ".=" ".-" ".." ".?" "+>" "++" "?:"
                "?=" "?." "??" ";;" "/*" "/=" "/>" "//" "__" "~~" "(*" "*)"
                "\\\\" "://"))
             ("Iosevka"
              '("<---" "<--"  "<<-" "<-" "->" "-->" "--->"
                "<->" "<-->" "<--->" "<---->" "<!--" "<==" "<==="
                "<=" "=>" "=>>" "==>" "===>" ">=" "<=>"
                "<==>" "<===>" "<====>" "<!---" "<~~" "<~" "~>"
                "~~>" "::" ":::" "==" "!=" "===" "!=="
                ":=" ":-" ":+" "<*" "<*>" "*>" "<|"
                "<|>" "|>" "+:" "-:" "=:" "<******>" "++"
                "+++"))))
        (global-ligature-mode t)))
#+end_src

Следующие два пакета: [[https://github.com/domtronn/all-the-icons.el][All The Icons]] и [[https://github.com/iyefrat/all-the-icons-completion][All The Icons Completion]] добавляют в интерфейс симуляцию иконок, выполняюемую специальными шрифтами.

#+begin_src emacs-lisp :tangle no
(use-package all-the-icons
    :straight t
    :if (display-graphic-p))

(use-package all-the-icons-completion
    :straight t
    :if (display-graphic-p)
    :after (all-the-icons marginalia)
    :hook (marginalia-mode . all-the-icons-completion-marginalia-setup)
    :config
    (all-the-icons-completion-mode))
#+end_src

На текущий момент я перешел к пакету [[https://github.com/rainstormstudio/nerd-icons.el][Nerd icons]], который предоставяляет ту же функциональность, но с применением одного шрифта вместо шести. Это позволяет добиться единого размера иконок. И, по какой-то причине, авторы [[https://github.com/seagle0128/doom-modeline][Doom Modeline]] перешли на него (причина кроется, видимо, в том, что эти иконки прекрасно работают в терминальном режиме).

[[https://github.com/rainstormstudio/nerd-icons-completion][Nerd icons completion]] и [[https://github.com/rainstormstudio/nerd-icons-dired][Nerd icons dired]] --- пакеты, добавляющие иконки в автодополнение в минибуфере и DirEd, соответственно. Первый из них нужно загружать с задержкой, иначе [[https://github.com/minad/marginalia][Marginalia]] не успеет их подхватить.

#+begin_src emacs-lisp
(use-package nerd-icons
    :straight t)

(use-package nerd-icons-completion
    :straight t
    :defer 1
    :after (all-the-icons marginalia)
    :config
    (nerd-icons-completion-mode t))

(use-package nerd-icons-dired
    :straight t
    :hook
    (dired-mode . nerd-icons-dired-mode))
#+end_src

* Настройки справки

Пакет [[https://github.com/minad/marginalia][Marginalia]] увеличивает объем дополнительной информации, отображаемой в минибуферах для различных команд.

#+begin_src emacs-lisp
(use-package marginalia
    :straight t
    :init
    (marginalia-mode))
#+end_src

[[https://github.com/justbur/emacs-which-key][Which Key]] помогает пользователю с комбинациями клавиш, коих в =Emacs= вагон и маленькая телега. Например, через 1 секунду после нажатия =C-x= появится минибуфер со списком возможных продолжений.

#+begin_src emacs-lisp
(use-package which-key
    :straight t
    :config
    (which-key-mode)
    :custom
    (which-key-idle-delay 1))
#+end_src

Пакет [[https://github.com/Wilfred/helpful][Helpful]] модифицирует и форматирует окна с документацией по функциям, переменным и т.д.

| Клавиша | Карта  | Команда          | Действие                                            |
|---------+--------+------------------+-----------------------------------------------------|
| =C-h f=   | global | helpful-callable | Справка по вызываемым символам: функциям и макросам |
| =<f1> f=  | global | helpful-callable | То же самое                                         |
| =C-h v=   | global | helpful-variable | Справка по переменным                               |
| =<f1> v=  | global | helpful-variable | Справка по переменным                               |
| =C-h k=   | global | helpful-key      | Справка по клавишам                                 |
| =C-h C=   | global | helpful-command  | Справка по командам                                 |

#+begin_src emacs-lisp
(use-package helpful
    :straight t
    :bind (([remap describe-function] . helpful-callable)
           ("<f1> f" . helpful-callable)
           ([remap describe-variable] . helpful-variable)
           ("<f1> v" . helpful-variable)
           ([remap describe-key] . helpful-key)
           ("C-h F" . helpful-function)
           ("C-h C" . helpful-command)))
#+end_src

* Настройки ввода

** Мышь

Следующие настройки меняют настройки прокрутки буферов при помощи мыши, а также включают изменение размера текста при помощи колеса прокрутки. Стандартные настройки приводят к чрезвычайно стремительному перемещению по тексту.

#+begin_src emacs-lisp
(setq mouse-wheel-scroll-amount '(1
                                  ((shift) . 5)
                                  ((meta))
                                  ((control) . text-scale))
      mouse-wheel-progressive-speed nil)

(setq auto-window-vscroll nil
      fast-but-imprecise-scrolling t
      scroll-conservatively 101
      scroll-margin 0
      scroll-preserve-screen-position t)

(when (>= emacs-major-version 29)
    (pixel-scroll-precision-mode))
#+end_src

[[https://github.com/abo-abo/hydra][Hydra]] позволяет снизить число нажатий клавиш при цепочке последовательных нажатий: достаточно ввести начальную комбинацию, затем ее можно опустить.

#+begin_src emacs-lisp
(use-package hydra
    :straight t)
#+end_src

** Клавиатура

Используем клавишу =ESC= для прерывания всего и вся. Работает не так хорошо, как =C-g=, но тем не менее.

#+begin_src emacs-lisp
(define-key global-map (kbd "<escape>") 'keyboard-escape-quit)
#+end_src

Настраиваем клавиши для изменения размера текста.

| Клавиша | Карта  | Команда | Действие                       |
|---------+--------+---------+--------------------------------|
| =C-==     | global |         | Сброс изменения размера текста |
| =C-+=     | global |         | Увеличение масштаба            |
| =C--=     | global |         | Уменьшение масштаба            |

#+begin_src emacs-lisp
(define-key global-map (kbd "C-=") #'(lambda ()
                                         (interactive)
                                         (text-scale-set 0)))
(define-key global-map (kbd "C-+") #'(lambda ()
                                         (interactive)
                                         (text-scale-increase 1.1)))
(define-key global-map (kbd "C--") #'(lambda ()
                                         (interactive)
                                         (text-scale-decrease 1.1)))
#+end_src

Убираем комбинацию клавиш, ранее использованную для отмены, так как она может путаться с комбинациями, приведенными выше.

#+begin_src emacs-lisp
(define-key global-map (kbd "C-_") nil)
#+end_src

[[https://github.com/a13/reverse-im.el][Reverse-IM]]... На данный пакет должны молиться все, кто пользуется несколькими раскладками клавиатуры. Пакет позволяет не переключать раскладку для ввода комбинаций клавиш. Не работает для ответов на вопрос =y= или =n=, тут надо, все-таки, переключать.

#+begin_src emacs-lisp
(use-package reverse-im
    :straight t
    :config
    (reverse-im-mode t)
    :custom
    (reverse-im-input-methods '("russian-computer")))
#+end_src

[[https://www.emacswiki.org/emacs/CuaMode][Cua Mode]] позволяет использовать стандартные комбинации клавиш =C-x=, =C-c=, =C-v=. Тут есть сложность: если есть активный регион (выделение), и нужно ввести комбинацию клавиш, включающую =C-x= или =C-c=, то нужно либо дважды быстро ввести нужное начало, либо использовать начало =C-S-x= или =C-S-c=.

#+begin_src emacs-lisp
(setq cua-keep-region-after-copy t)
(cua-mode t)
(transient-mark-mode t)
#+end_src

* Настройки редактирования

Если регион активен (то есть активно выделение), то начало ввода очищает выделение.

#+begin_src emacs-lisp
(delete-selection-mode t)
#+end_src

** Настройки сохранения

Удаление пробелов в конце строк во время сохранения.

#+begin_src emacs-lisp
(add-hook 'before-save-hook 'delete-trailing-whitespace)
#+end_src

Добавление пустой строки при сохранении.

#+begin_src emacs-lisp
(setq require-final-newline t)
#+end_src

** Настройки отступов

Настраиваем ширину табуляции в 4 пробела, а также запрещаем отступы знаками табуляции.

#+begin_src emacs-lisp
(setq-default indent-tabs-mode nil
              tab-width 4
              c-basic-offset 4
              standart-indent 4
              lisp-body-indent 4)
#+end_src

Активация встроенного механизма автоматической расстановки отступов. Попробовал [[https://github.com/Malabarba/aggressive-indent-mode][aggressive-indent-mode]], но он оказался слишком агрессивным.

#+begin_src emacs-lisp
(electric-indent-mode t)
#+end_src

#+begin_src emacs-lisp :tangle no
(use-package aggressive-indent
    :straight t
    :hook (((prog-mode LaTeX) . aggressive-indent-mode)))
#+end_src

Настраиваем поведение клавиши =RET=: при нажатии на нее происхоит не только перенос строки, но и коррекция отступа введенной строки.

#+begin_src emacs-lisp
(define-key global-map (kbd "RET") 'newline-and-indent)
#+end_src

Визуально показываем уровни отступа при помощи [[https://github.com/DarthFennec/highlight-indent-guides][highlight-indent-guides]].

#+begin_src emacs-lisp
(use-package highlight-indent-guides
    :straight t
    :if ensure/isWindows
    :hook (prog-mode . highlight-indent-guides-mode)
    :custom
    (highlight-indent-guides-method 'character)
    (highlight-indent-guides-responsive 'top))
#+end_src

** Настройки отмены и повтора

Пакет [[https://gitlab.com/tsc25/undo-tree][Undo Tree]] заменяет стандартный механизм отмены и повтора. Главное отличие: история отмены и повторов отображается в виде дерева, вместо стандартного линейного представления =Emacs=, что делает отмену более удобной при более предсказуемом поведении.

| Клавиша | Карта  | Команда        | Действие        |
|---------+--------+----------------+-----------------|
| =C-z=     | global | undo-tree-undo | Отмена действий |
| =C-S-z=   | global | undo-tree-redo | Повтор действий |

#+begin_src emacs-lisp
(use-package undo-tree
    :straight t
    :init
    (unbind-key "C-z" global-map)
    (unbind-key "C-_" global-map)
    (unbind-key "C-M-_" global-map)
    :bind (("C-z" . undo-tree-undo)
           ("C-S-z" . undo-tree-redo)
           :map cua--cua-keys-keymap
           ("C-z" . undo-tree-undo))
    :config
    (global-undo-tree-mode)
    :custom
    (undo-tree-history-directory-alist `(("." . ,(format "%s/undo"
                                                        user-emacs-directory)))))
#+end_src

** Настройки отражения скобок

Активация подсветки парных скобок.

#+begin_src emacs-lisp
(show-paren-mode t)
#+end_src

Пакет [[https://github.com/Fanael/rainbow-delimiters][Rainbow Delimeters]] раскрашивает парные скобки в зависимости от глубины вложенности.

#+begin_src emacs-lisp
(use-package rainbow-delimiters
    :straight t
    :hook ((prog-mode org-mode) . rainbow-delimiters-mode))
#+end_src

Пакет [[https://github.com/Fuco1/smartparens][Smartparens]] автоматически добавляет закрывающие скобки, причем и довольно сложные, такие как скобки LaTeX. Также пакет добавляет функции для смены окружающих скобок и их удаления.

| Клавиша | Карта  | Команда        | Действие                   |
|---------+--------+----------------+----------------------------|
| =C-c b r= | global | sp-rewrap-sexp | Смена окружающих скобок    |
| =C-c b d= | global | sp-splice-sexp | Удаление окружающих скобок |

#+begin_src emacs-lisp :noweb
(if (not (string-equal init/completion-popup "company"))
        (use-package smartparens
            :straight t
            :demand t
            :bind (:map smartparens-mode-map
	                    ("C-c b r" . sp-rewrap-sexp)
                        ("C-c b d" . sp-splice-sexp))
            :config
            (require 'smartparens-config)
            (smartparens-global-mode t)
            (sp-with-modes '(tex-mode
                             latex-mode
                             LaTeX-mode)
                (sp-local-pair "<<" ">>"
                               :unless '(sp-in-math-p))))
    (electric-pair-mode t))
#+end_src

** Настройки комментирования

[[https://stackoverflow.com/a/9697222][Данная функция]] позволяет одной комбинацией клавиш закомментировать либо строку, либо регион.

| Клавиша | Карта  | Команда | Действие                           |
|---------+--------+---------+------------------------------------|
| =M-;=     | global |         | Комментирование строки или региона |

#+begin_src emacs-lisp
(defun comment-or-uncomment-region-or-line ()
    "Comments or uncomments the region or the current line."
    (interactive)
    (let (beg end)
        (if (region-active-p)
                (setq beg (region-beginning) end (region-end))
            (setq beg (line-beginning-position) end (line-end-position)))
        (comment-or-uncomment-region beg end)
        (forward-line)))

(global-set-key (kbd "M-;") 'comment-or-uncomment-region-or-line)
#+end_src

** Настройки замены

[[https://github.com/benma/visual-regexp.el][Visual Regexp]] показывает результат предположительной замены. Причем понимает регулярные выражения.

| Клавиша | Карта  | Команда          | Действие                                                    |
|---------+--------+------------------+-------------------------------------------------------------|
| =M-%=     | global | vr/replace       | Визуальная замена                                           |
| =C-M-%=   | global | vr/query-replace | Последовательная визуальная замена                          |
| =C-c v m= | global | vr/mc-mark       | Создание нескольких курсоров согласно регулярномы выражению |

#+begin_src emacs-lisp
(defun my/vr/replace ()
    "Replace in whole buffer."
    (interactive)
    (if (region-active-p)
            (call-interactively #'vr/replace)
        (save-excursion
            (goto-char (point-min))
            (call-interactively #'vr/replace))))

(defun my/vr/query-replace ()
    "Replace in whole buffer."
    (interactive)
    (if (region-active-p)
            (call-interactively #'vr/query-replace)
        (save-excursion
            (goto-char (point-min))
            (call-interactively #'vr/query-replace))))

(use-package visual-regexp
    :straight t
    :bind (("M-%" . my/vr/replace)
           ("C-M-%" . my/vr/query-replace)
           ("C-c v m" . my/vr/mc-mark)))
#+end_src

Пакет [[https://github.com/magnars/multiple-cursors.el][Multiple Cursors]] позволяет создавать несколько курсоров, либо выделяющих одинаковый текст в разных строках, либо создающих столбец из курсоров.

| Клавиша | Карта  | Команда                    | Действие                                        |
|---------+--------+----------------------------+-------------------------------------------------|
| =C-c m l= | global | mc/edit-lines              | Создание нескольких курсоров в пределах региона |
| =C->=     | global | mc/mark-next-like-this     | Создание курсора на следующем вхождении слова   |
| =C-<=     | global | mc/mark-previous-like this | Создание курсора на предыдущем вхождении слова  |
| =C-c m a= | global | mc/mark-all-like-this      | Создание курсоров на всех вхождениях слова      |

#+begin_src emacs-lisp
(use-package multiple-cursors
    :straight t
    :bind (("C-c m l" . mc/edit-lines)
           ("C->" . mc/mark-next-like-this)
           ("C-<" . mc/mark-previous-like-this)
           ("C-c m a" . mc/mark-all-like-this))
    :custom
    (mc/match-cursor-style nil))
#+end_src

** Полезные команды

[[https://github.com/bbatsov/crux][Crux]] --- набор различных полезных функций.

| Клавиша      | Карта  | Команда                                           | Действие                                             |
|--------------+--------+---------------------------------------------------+------------------------------------------------------|
| =C-c I=        | global | crux-find-user-init-file                          | Перейти к пользовательскому файлу =init.el=            |
| =C-c d=        | global | crux-duplicate-current-line-or-region             | Создать дубликат строки или региона                  |
| =C-c M-d=      | global | crux-duplicate-and-comment-current-line-or-region | Создать *комментированный* дубликат строки или региона |
| =S-<return>=   | global | crux-smart-open-line                              | Создать строку после текущей (как =o= в =Vim=)           |
| =C-S-<return>= | global | crux-smart-open-line-above                        | Создать строку перед текущей (как =O= в =Vim=)           |

#+begin_src emacs-lisp
(use-package crux
    :straight t
    :bind (("C-c I" . crux-find-user-init-file)
           ("C-c d" . crux-duplicate-current-line-or-region)
           ("C-c M-d" . crux-duplicate-and-comment-current-line-or-region)
           ("S-<return>" . crux-smart-open-line)
           ("C-S-<return>" . crux-smart-open-line-above)))
#+end_src

* Настройки автодополнения

** Вспомогательные функции

Так как в файле =init.el= есть возможность выбора механизмов автодополнения, то для максимальной унификации настроек я написал вспомогательные функции, вызывающие нужные компоненты.

#+begin_src emacs-lisp
(use-package cape
    :straight t
    :config
    (add-to-list 'completion-at-point-functions #'cape-file t))
#+end_src

Первая функция запускает нужный клиент LSP: =LSP-mode= или =Eglot=.

#+begin_src emacs-lisp
(defun lsp/lsp ()
    "Using an appropriate LSP-engine."
    (cond ((string-equal init/lsp-engine "lsp")
           (lsp))
          ((string-equal init/lsp-engine "eglot")
           (eglot-ensure))
          (t
           (error "Unknown LSP-engine `%s'" init/lsp-engine))))
#+end_src

Клиенты LSP добавляют свои собственные CAPF (Conpletion at Point Function). Однако, эти CAPF являются `жадными`: если они не могут предоставить пользователю результат, то дальнейший поиск вариантов автодополнения останавливается. Так как я настраиваю поиск вариантов автодополнения из нескольких источников, то такое поведение неприемлемо.

#+begin_src emacs-lisp
(defun lsp/non-greedy-lsp-mode ()
    "Making LSP capf non-greedy."
    (progn
        (fset 'non-greedy-lsp
              (cape-capf-properties #'lsp-completion-at-point :exclusive 'no))
        (setq completion-at-point-functions
              (list #'non-greedy-lsp))))

(defun lsp/non-greedy-eglot ()
    "Making Eglot capf non-greedy."
    (progn
        (fset 'non-greedy-eglot
              (cape-capf-properties #'eglot-completion-at-point :exclusive 'no))
        (setq completion-at-point-functions
              (list #'non-greedy-eglot))))
#+end_src

При открытии некоторых видов файлов и соответствующих языковых серверов в список CAPF добавляются дополнительные источники вариантов автодополнения. Следующая функция предназначена для автоматического запуска вспомогательных функций, добавляющих оные. Эти вспомогательные функции должжны иметь имя =capf/<major-mode>=.

#+begin_src emacs-lisp
(defun lsp/extra-capf ()
    "Adding extra capf during LSP startup."
    (let ((tmp-symbol (intern (concat "capf/" (symbol-name major-mode)))))
        (unless (null (symbol-function tmp-symbol))
            (funcall (symbol-function tmp-symbol)))))
#+end_src

** LSP

Устанавливаем и запускаем =LSP-mode= или =Eglot=. При их запуске выполняются два хука: первый делает соответствующий CAPF `щедрым`, а второй --- добавляет дополнительные CAPF.

| Клавиша | Карта        | Команда         | Действие                               |
|---------+--------------+-----------------+----------------------------------------|
| =C-c l=   | lsp-mode-map | lsp-command-map | Префикс для комбинаций клавиш LSP-mode |

| Клавиша | Карта          | Команда                            | Действие                                             |
|---------+----------------+------------------------------------+------------------------------------------------------|
| =C-c l r= | eglot-mode-map | eglot-rename                       | Переименовать символ под курсором                    |
| =C-c l o= | eglot-mode-map | eglot-code-action-organize-imports | Форматирование списка импортированных файлов/модулей |
| =C-c l h= | eglot-mode-map | eldoc                              | Справка Eldoc                                        |
| =C-c l d= | eglot-mode-map | xref-find-definitions              | Переход к определению символа                        |

#+begin_src emacs-lisp
(when (string-equal init/lsp-engine "lsp")
    (use-package lsp-mode
        :straight t
        :hook ((lsp-mode . lsp-enable-which-key-integration)
               (lsp-completion-mode . (lambda ()
                                          (progn
                                              (lsp/non-greedy-lsp-mode)
                                              (lsp/extra-capf)))))
        :config
        (with-eval-after-load 'lsp-mode
            (define-key lsp-mode-map (kbd "C-c l") lsp-command-map))
        :custom
        (lsp-headerline-breadcrumb-icons-enable nil)
        (lsp-enable-file-watchers nil)
        (lsp-keymap-prefix "C-c l")
        (lsp-completion-provider :none))
    (use-package lsp-ui
        :straight t))

(when (string-equal init/lsp-engine "eglot")
    (use-package eglot
        :init
        (when (< emacs-major-version 29)
            (straight-use-package 'eglot))
        :hook (eglot-managed-mode . (lambda ()
                                        (progn
                                            (lsp/non-greedy-eglot)
                                            (lsp/extra-capf))))
        :bind (:map eglot-mode-map
                    ("C-c l r" . eglot-rename)
                    ("C-c l o" . eglot-code-action-organize-imports)
                    ("C-c l h" . eldoc)
                    ("C-c l d" . xref-find-definitions))
        :config
        (add-to-list 'eglot-server-programs
                     '(latex-mode . ("texlab")))))
#+end_src

** =Corfu= или =Company=

[[https://github.com/minad/corfu][Corfu]] --- минималистичное всплывающее окно для автодополнения. Не требует дополнительных `бэкендов` для работы, использует встроенную в =Emacs= функциональность. Также устанавливается пакет [[https://github.com/galeo/corfu-doc][Corfu-doc]], добавляющий всплявающее окно со справкой. Для визуальных красот устанавливается пакет [[https://github.com/jdtsmith/kind-icon][Kind-icon]], добавляющий красивые иконки. Пакет [[https://github.com/minad/cape][Cape]] содержит набор инструментов для модификации CAPF, при помощи которых, собственно, и модифицировались выше CAPF для LSP.

В силу архитектурных особенностей =Corfu= и =Corfu-doc= не умеют работать в терминальном режиме, поэтому параллельно устанавливаются пакеты [[https://codeberg.org/akib/emacs-corfu-terminal][Corfu-terminal]] и [[https://codeberg.org/akib/emacs-corfu-doc-terminal][Corfu-doc-terminal]]. Также устанавливаются необходимый пакет [[https://codeberg.org/akib/emacs-popon][Emacs-popon]] (так как последние три пакета теперь есть в NonGNU ELPA, то, возможно, что ручная установка более не требуется).

| Клавиша | Карта     | Команда        | Действие           |
|---------+-----------+----------------+--------------------|
| =TAB=     | corfu-map | corfu-next     | Следующий вариант  |
| =S-TAB=   | corfu-map | corfu-previous | Предыдущий вариант |

#+begin_src emacs-lisp
(when (string-equal init/completion-popup "corfu")
    (use-package corfu
        :straight (:files (:defaults "extensions/*"))
        :bind (:map corfu-map
                    ("TAB" . corfu-next)
                    ([tab] . corfu-next)
                    ("S-TAB" . corfu-previous)
                    ([backtab] . corfu-previous))
        :init
        (corfu-popupinfo-mode)
        (global-corfu-mode)
        :custom
        (corfu-auto nil)
        (corfu-cycle t)
        (corfu-preselect-first nil)
        (corfu-preview-current 'insert)
        (tab-always-indent 'complete)
        (corfu-popupinfo-delay 0.2))

    (use-package kind-icon
        :straight t
        :after (corfu nerd-icons)
        :config
        (add-to-list 'corfu-margin-formatters #'kind-icon-margin-formatter)
        :custom
        (kind-icon-default-face 'corfu-default)))
#+end_src

При желании можно использовать [[https://company-mode.github.io/][Company Mode]] в связке с [[https://github.com/sebastiencs/company-box][Company Box]] (для иконок). В целом, все аналогично приведенному выше набору пакетов, однако есть нюансы. Во-первых, =Company= использует собственный механизм бэкендов, а во-вторых, он не совместим со =Smartparens=, происходит дублирование закрывающей скобки. Насколько мне известно, это еще [[https://github.com/Fuco1/smartparens/issues/445][не исправлено]].

#+begin_src emacs-lisp
(when (string-equal init/completion-popup "company")
    (use-package company
        :straight t
        :bind (([remap indent-for-tab-command] . company-indent-or-complete-common)
               :map company-active-map
               ("RET". company-complete-selection)
               ("<return>". company-complete-selection)
               ("<tab>" . company-complete-common-or-cycle)
               ("ESC" . company-abort)
               ("<esc>" . company-abort))
        :hook (after-init . global-company-mode)
        :init
        (setq company-backends '((company-capf)))
        :custom
        (company-selection-wrap-around t)
        (company-minimum-prefix-length 1)
        (company-idle-delay nil)
        (company-tooltip-align-annotations t)
        (company-transformers '(delete-consecutive-dups
                                company-sort-by-occurrence
                                company-sort-prefer-same-case-prefix)))

    (use-package company-box
        :straight t
        :hook (company-mode . company-box-mode)))
#+end_src

** =Vertico=, =Consult= и =Embark= или =Ivy=

Если описанные выше пакеты =Corfu= и =Company= служат для облегчения автодополнения при работе в основных буферах, то следующие предназначены для минибуфера. [[https://github.com/minad/vertico][Vertico]] является облегченным аналогом =Ivy= или =Helm=, опирающимся на встроенные в =Emacs= возможности.

[[https://github.com/minad/consult][Consult]] представляет собой набор функций, расширяющих встроенные в =Emacs= аналоги.

[[https://github.com/oantolin/embark][Embark]] позволяет выполнить некоторое стандартное действие в зависимости от того, что находится под курсором.

[[https://github.com/oantolin/orderless][Orderless]] дает возможность поиска в минибуфере при помощи ввода некоторого набора условий (например частей строк), разделенных пробелами. Будут показаны кандидаты, соответствующие всем условиям в *произвольном* порядке.

| Клавиша | Карта  | Команда         | Действие                                     |
|---------+--------+-----------------+----------------------------------------------|
| =C-x b=   | global | consult-buffer  | Меню выбора буфера                           |
| =C-x C-b= | global | ibuffer         | "Стандартное" меню выбора буфера             |
| =C-.=     | global | embark-act      | Меню выбора действия с объектом под курсором |
| =C-;=     | global | embark-dwim     | Выполнение стандартного действия с объектом  |
| =C-h B=   | global | embark-bindings | Меню со справкой по комбинациям клавиш       |
| =C-s=     | global | consult-line    | Поиск строк по шаблону                       |
| =M-R=     | global | vertico-repeat  | Повтор предыдущего поиска                    |

#+begin_src emacs-lisp
(when (equal init/completion-minibuf "vertico")
    (use-package vertico
        :straight (:files (:defaults "extensions/*"))
        :hook ((minibuffer-setup . (lambda ()
                                      (setq completion-in-region-function
                                            (if vertico-mode
                                                    #'consult-completion-in-region
                                                #'completion--in-region))))
               (minibuffer-setup . vertico-repeat-save))
        :init
        (add-to-list 'process-coding-system-alist
                     '("[rR][gG]" . (utf-8-dos . windows-1251-dos)))
        (vertico-mode)
        :bind (("M-R" . vertico-repeat))
        :custom
        (vertico-cycle t)
        (vertico-mouse-mode t)
        (vertico-count 8)
        (vertico-count 8))

    (use-package consult
        :straight t
        :bind (("C-x b" . consult-buffer)
               ("C-x C-b" . ibuffer)
               ("C-s" . consult-line)
               ("C-S-s" . consult-ripgrep)))

    (use-package embark
        :straight t
        :bind (("C-." . embark-act)
               ("C-;" . embark-dwim)
               ("C-h B" . embark-bindings))
        :custom
        (prefix-help-command #'embark-prefix-help-command))

    (use-package embark-consult
        :straight t
        :after (embark consult)
        :hook (embark-collect-mode . consult-preview-at-point-mode))


    (use-package orderless
        :straight t
        :custom
        (completion-styles '(orderless basic))
        (completion-category-defaults nil)
        (completion-category-overrides '((file (styles basic partial-completion))))))
#+end_src

[[https://github.com/abo-abo/swiper][Ivy]] является инструментом, альтернативным =Vertico=.

| Клавиша | Карта  | Команда                    | Действие                                |
|---------+--------+----------------------------+-----------------------------------------|
| =C-s=     | global | swiper-isearch             | Поиск строк по шаблону                  |
| =M-x=     | global | counsel-M-x                | Меню интерактивных команд               |
| =C-x C-f= | global | counsel-find-file          | Меню открытия файлов                    |
| =M-y=     | global | counsel-yank-pop           | Меню kill-ring                          |
| =<f1> l=  | global | counsel-find-library       | Переход к исходному коду библиотеки     |
| =<f2> i=  | global | counsel-info-lookup-symbol | Поиск справки для символа               |
| =<f2> u=  | global | counsel-unicode-char       | Поиск символа Юникод                    |
| =<f2> j=  | global | counsel-set-variable       | Изменение значения переменной           |
| =C-x b=   | global | ivy-switch-buffer          | Переключение буферов при помощи =Ivy=     |
| =C-x C-b= | global | ibuffer                    | Переключение буферов при помощи =ibuffer= |
| =C-c v=   | global | ivy-push-view              |                                         |
| =C-c V=   | global | ivy-pop-view               |                                         |
| =M-R=     | global | ivy-resume                 | Повтор предыдущего поиска               |

#+begin_src emacs-lisp
  (when (equal init/completion-minibuf "ivy")
      (use-package counsel
          :straight t
          :config
          (ivy-mode t)
          :bind (("C-x b"   . ivy-switch-buffer)
                 ("C-x C-b" . ibuffer)
                 ("C-c v"   . ivy-push-view)
                 ("C-c V"   . ivy-pop-view)
                 ("M-R"     . ivy-resume)
                 ("C-s"     . swiper-isearch)
                 ("M-x"     . counsel-M-x)
                 ("C-x C-f" . counsel-find-file)
                 ("M-y"     . counsel-yank-pop)
                 ("<f1> l"  . counsel-find-library)
                 ("<f2> i"  . counsel-info-lookup-symbol)
                 ("<f2> u"  . counsel-unicode-char)
                 ("<f2> j"  . counsel-set-variable))
          :custom
          (ivy-use-virtual-buffers t)
          (ivy-count-format "(%d/%d) ")
          (ivy-wrap t))

      (use-package ivy-rich
          :straight t
          :after (counsel)
          :init
          (setcdr (assq t ivy-format-functions-alist) #'ivy-format-function-line)
          :config
          (ivy-rich-mode 1))

      (use-package nerd-icons-ivy-rich
          :straight t
          :init
          (nerd-icons-ivy-rich-mode 1)))
#+end_src

** Сниппеты

[[https://github.com/minad/tempel][Tempel]] является переосмыслением встроенного механизма сниппетов =tempo= от автора =Vertico= и =Corfu=. Удобен, привычен для давних пользователей =Emacs=, поскольку в целом повторяет синтаксис описания шаблонов =tempo=.

| Клавиша | Карта      | Команда       | Действие                      |
|---------+------------+---------------+-------------------------------|
| =S-TAB=   | global     | tempel-expand | Разворачивание шаблона        |
| =S-TAB=   | tempel-map | tempel-done   | Завершение заполнения шаблона |
| =<f7>=    | global     | tempel-insert | Меню шаблонов                 |

#+begin_src emacs-lisp
(when (string-equal init/snippet-engine "tempel")
    (use-package tempel
        :straight t
        :bind (("<backtab>" . tempel-complete)
               ("<f7>" . tempel-insert)
               :map tempel-map
               ("<backtab>" . tempel-done))
        :custom
        (tempel-path (expand-file-name
                      "templates"
                      (file-name-directory user-init-file)))))
#+end_src

Но на текущий момент многие воспринимают как стандарт [[https://github.com/joaotavora/yasnippet][Yasnippet]] (а точнее формат шаблонов [[http://manual.macromates.com/en/snippets][TextMate]]): ряд LSP возвращают сниппеты в совместимом с Yasnippet формате, что позволяет ему подхватывать их `на лету`.

[[https://github.com/AndreaCrotti/yasnippet-snippets][Yasnippet-snippets]] добавляет коллекцию сниппетов для большого числа разных языков программирования. [[https://github.com/mohkale/consult-yasnippet][Consut-Yasnippet]] включает поддержку =Yasnippet= в =Consult=.

| Клавиша | Карта  | Команда           | Действие      |
|---------+--------+-------------------+---------------|
| =<f7>=    | global | consult-yasnippet | Меню шаблонов |

#+begin_src emacs-lisp
(when (string-equal init/snippet-engine "yasnippet")
    (use-package yasnippet
        :straight t
        :bind (:map yas-minor-mode-map
                     ([(tab)] . nil)
                     ("TAB" . nil))
        :config
        (yas-global-mode 1))

    (use-package yasnippet-snippets
        :straight t)

    (use-package consult-yasnippet
        :straight t
        :after (vertico)
        :bind ("<f7>" . consult-yasnippet)))
#+end_src

* Настройки для языков программирования

[[https://github.com/bbatsov/projectile][Projectile]] --- пакет для удобного управления проектами, дающий возможность поиска и замены по проекту и т. д.

| Клавиша | Карта  | Команда                | Действие                                 |
|---------+--------+------------------------+------------------------------------------|
| =C-c p=   | global | projectile-command-map | Префикс для комбинаций клавиш Projectile |

#+begin_src emacs-lisp
(use-package projectile
    :straight t
    :bind-keymap ("C-c p" . projectile-command-map)
    :config
    (projectile-mode t)
    :custom
    (projectile-completion-system 'default))
#+end_src

[[https://github.com/flycheck/flycheck][Flycheck]] служит для провеки синтаксиса "на лету".

#+begin_src emacs-lisp
(use-package flycheck
    :straight t
    :config
    (global-flycheck-mode))
#+end_src

Magit --- пакет для работы с git внутри Emacs.

#+begin_src emacs-lisp
(use-package magit
    :straight t)
#+end_src

Переназначение главных режимов для языков программирования для использования =Tree-Sitter=, работает только в Emacs 29 и новее.

#+begin_src emacs-lisp
(when (>= emacs-major-version 29)
    (setq major-mode-remap-alist
          '((python-mode . python-ts-mode))))
#+end_src

** Markdown

#+begin_src emacs-lisp
(use-package markdown-mode
    :straight t
    :mode (("README\\.md\\'" . gfm-mode)
           ("\\.md\\'" . markdown-mode)
           ("\\.markdown\\'" . markdown-mode))
    :custom
    (markdown-fontify-code-blocks-natively t)
    (markdown-command "multimarkdown"))
#+end_src

** Org-mode

Данная настройка отключает проверку соответствия для угловых скобок в org-файлах.

#+begin_src emacs-lisp
(defun my/angle-brackets-fix ()
    (modify-syntax-entry ?< "." org-mode-syntax-table)
    (modify-syntax-entry ?> "." org-mode-syntax-table))
#+end_src

[[https://github.com/sabof/org-bullets][Org-bullets]] позволяет настроить метки при разделах org-документа. [[https://github.org/snosov1/toc-org][TOC-org]] дает возможность более гибкой настройки оглавления. [[https://github.com/awth13/org-appear][org-appear]] сворачивает форматирование в org-документах, разворачивая при наведении курсора. [[https://github.com/Fanael/edit-indirect][Edit-indirect]] дает возможность редактирования блоков с исходным кодом в отдельных буферах.

#+begin_src emacs-lisp
(use-package org
    :straight t
    :hook ((org-mode . org-indent-mode)
           (org-mode . my/angle-brackets-fix))
    :config
    (org-babel-do-load-languages
     'org-babel-load-languages '((emacs-lisp . t)
                                 (python . t)
                                 (lua . t)
                                 (haskell . t)
                                 (shell . t)))
    :config
    (require 'org-tempo)
    (progn
        (add-to-list 'org-structure-template-alist '("sh" . "src shell"))
        (add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
        (add-to-list 'org-structure-template-alist '("hs" . "src haskell"))
        (add-to-list 'org-structure-template-alist '("lua" . "src lua"))
        (add-to-list 'org-structure-template-alist '("py" . "src python"))
        (add-to-list 'org-structure-template-alist '("tex" . "src tex")))
    :custom
    (org-edit-src-content-indentation 0)
    (org-src-preserve-indentation nil)
    (org-src-fontify-natively t)
    (org-src-tab-acts-natively t)
    (org-return-follows-link t)
    (org-mouse-1-follows-link t)
    (org-descriptive-links t)
    (org-hide-emphasis-markers t)
    (org-support-shift-select t))

(use-package edit-indirect
    :straight t)

(use-package org-bullets
    :straight t
    :after org
    :hook (org-mode . org-bullets-mode)
    :custom
    (org-bullets-bullet-list '("◉" "○" "●" "○" "●" "○" "●")))

(use-package toc-org
    :straight t
    :after org
    :hook (org-mode . toc-org-mode))

(use-package org-appear
    :straight (org-appear :type git :host github :repo "awth13/org-appear")
    :after org
    :hook (org-mode . org-appear-mode)
    :custom
    (org-appear-autolinks t)
    (org-appear-autosubmarkers t))
#+end_src

** ESS

#+begin_src emacs-lisp
(use-package ess
    :straight t
    :mode (("\\.R$" . ess-r-mode)
           ("\\.do$" . ess-stata-mode))
    :hook ((ess-r-mode . lsp/lsp)
           (ess-r-post-run . ess-rdired)
           ((ess-r-mode ess-stata-mode) . (lambda ()
                                              (setq-local fill-column 80)
                                              (display-fill-column-indicator-mode))))
    :init
    (unless (getenv "LC_ALL")
        (setenv "LC_ALL" "ru_RU.UTF-8"))
    (setq display-buffer-alist
          (append `(("^\\*R Dired"
                     (display-buffer-reuse-window display-buffer-in-side-window)
                     (side . right)
                     (slot . -1)
                     (window-width . 0.33)
                     (reusable-frames . nil))
                    ("^\\*R view"
                     (display-buffer-reuse-window display-buffer-in-side-window)
                     (side . right)
                     (slot . 1)
                     (window-width . 0.33)
                     (reusable-frames . nil))
                    ("^\\*R"
                     (display-buffer-reuse-window display-buffer-in-side-window)
                     (side . right)
                     (slot . 1)
                     (window-width . 0.33)
                     (reusable-frames . nil)))
                  display-buffer-alist)))
#+end_src

** Python

Функция для модификации списка CAPF при открытии Python-файлов.

#+begin_src emacs-lisp
(defun capf/python-mode ()
    "Extra CAPF for `python-mode'."
    (setq completion-at-point-functions
          (append completion-at-point-functions
                  (list 'cape-file))))

(defalias 'capf/python-ts-mode 'capf/python-mode)
#+end_src

#+begin_src emacs-lisp
(use-package python
    :straight lsp-pyright
    :hook (((python-mode python-ts-mode) . lsp/lsp)
           ((python-mode python-ts-mode) . (lambda ()
                                               (setq-local fill-column 80)
                                               (display-fill-column-indicator-mode)))))
#+end_src

** JS

Для начала надо установить =typescript= и =typescript-language-server= через =npm=.

#+begin_src shell :tangle no
npm i -g typescript-language-server; npm i -g typescript
#+end_src

#+begin_src emacs-lisp
(use-package js
    :mode "\\.js.R$"
    :hook (js-mode . lsp/lsp))
#+end_src

** Lua

#+begin_src emacs-lisp
(use-package lua-mode
    :straight t
    :mode "\\.lua$"
    :custom
    (lua-indent-level 4))
#+end_src

** LaTeX

Функция для модификации списка CAPF при открытии Python-файлов. Следует отметить, что для =Company= существует ряд бэкендов, полезных для редактирования LaTeX-документов. При помощи =Cape= эти бэкенды преобразуются в CAPF.

#+begin_src emacs-lisp
(defun capf/latex-mode ()
    "Extra CAPF for `LaTeX-mode'."
    (progn
        (fset 'cape/company-reftex-labels
              (cape-company-to-capf #'company-reftex-labels))
        (fset 'cape/company-reftex-citations
              (cape-company-to-capf #'company-reftex-citations))
        (fset 'cape/company-math-symbols-latex
              (cape-company-to-capf #'company-math-symbols-latex))
        (fset 'cape/company-math-symbols-unicode
              (cape-company-to-capf #'company-math-symbols-unicode))
        (setq completion-at-point-functions
              (append completion-at-point-functions
                      (list 'cape/company-reftex-labels
                            'cape/company-reftex-citations
                            'cape/company-math-symbols-latex
                            'cape/company-math-symbols-unicode)))))
#+end_src

На случай, если нужно будет переписать файл настроек без LSP, определим функцию для отключения "жадности" CAPF, встроенного в AuCTeX.

#+begin_src emacs-lisp
(defun auctex/non-greedy-capf ()
    "Making AUCTeX capf non-greedy."
    (progn
        (fset 'non-greedy-tex
              (cape-capf-properties #'TeX--completion-at-point :exclusive 'no))
        (setq completion-at-point-functions
              (list 'non-greedy-tex))))
#+end_src

Добавление =LaTeX Make= в список процедур для компиляции LaTeX-документов.

#+begin_src emacs-lisp
(defun auctex/extra-commands ()
    "Add a command for TeX-file compilation via latexmk."
    (add-to-list
     'TeX-command-list
     '("LaTeX Make / PDFLaTeX"
       "latexmk -pdf -cd -f -interaction=nonstopmode -synctex=1 -shell-escape -outdir=output %t"
       TeX-run-TeX nil t
       :help "Make the file using Latexmk/PDFLaTeX."))
    (add-to-list
     'TeX-command-list
     '("LaTeX Make / XeLaTeX"
       "latexmk -pdfxe -cd -f -interaction=nonstopmode -synctex=1 -shell-escape -outdir=output %t"
       TeX-run-TeX nil t
       :help "Make the file using XeTeX."))
    (add-to-list
     'TeX-command-list
     '("LaTeX Make / LuaLaTeX"
       "latexmk -pdflua -cd -f -interaction=nonstopmode -synctex=1 -shell-escape -outdir=output %t"
       TeX-run-TeX nil t
       :help "Make the file using LuaTeX.")))
#+end_src

Далее ряд служебных *неинтерактивных* функций. Первая активирует регион, основанный на текущем окружении LaTeX или параграфе.

#+begin_src emacs-lisp
(defun my/region-or-env-or-paragraph ()
    "Produce region from LaTeX environment or paragraph if no any already."
    (unless (region-active-p)
        (if (equal major-mode 'latex-mode)
                (LaTeX-mark-environment)
            (mark-paragraph))
        (let ((beg (save-excursion
                       (goto-char (region-beginning))
                       (forward-line)
                       (line-beginning-position)))
              (end (if (equal major-mode 'latex-mode)
                           (save-excursion
                               (goto-char (region-end))
                               (forward-line (if (equal (point) (line-end-position))
                                                     -1
                                                 -2))
                               (line-end-position))
                       (region-end))))
            (set-mark beg)
            (goto-char end)
            (setq deactivate-mark nil))))
#+end_src

Вторая --- увеличивет регион на 1 символ, если это возможно.

#+begin_src emacs-lisp
(defun my/region-expand-one-char ()
    "Add extra char to the end of region if possible."
    (if (and (= (region-end) (line-end-position))
             (/= (region-end) (line-beginning-position))
             (/= (region-end) (point-max)))
            (1+ (region-end))
        (region-end)))
#+end_src

Третья --- добавляет строку к файлу, если регион находится в *конце* файла и заканчивается *не в конце* строки.

#+begin_src emacs-lisp
(defun my/point-add-one-char (end)
    "Add new line if END is the last char and not at line-beginning."
    (interactive "r")
    (save-excursion
        (goto-char end)
        (if (and (= end (point-max))
                 (= end (line-end-position))
                 (/= end (line-beginning-position)))
                (insert "\n"))))
#+end_src

Четвертая --- пробегает по региону и заменяет все амперсанды *внутри* фигурных скобок (то есть внутри какой-либо команды) на логотип Emacs из набора Nerd Icons. Выбор обусловлен тем, что этот символ с *очень* небольшой вероятностью появится в каком-либо реальном документе.

#+begin_src emacs-lisp
(defun my/protect-inner-amps ()
    "Protect ampersands in curly brackets."
    (let ((pos (point-min))
          (innerno 0))
        (while (< pos (point-max))
            (goto-char pos)
            (pcase (string (char-after pos))
                ("{" (setq innerno (1+ innerno)))
                ("}" (setq innerno (1- innerno)))
                ("&" (if (> innerno 0) (progn
                                           (delete-char 1)
                                           (insert "@")))))
            (setq pos (1+ pos)))
        (goto-char (point-min))
        (while (search-forward-regexp "\\\\&" nil t)
            (replace-match "\\\\@" nil nil))))

(defun my/unprotect-inner-amps ()
    "Restore protected ampersands."
    (goto-char (point-min))
            (while (search-forward "@" nil t)
                (replace-match "&" nil nil)))
#+end_src

Эти функции нужны для следующих двух интерактивных функций. Первая преобразует таблицы в виде данных с разделителями в формат LaTeX.

#+begin_src emacs-lisp
(defun auctex/table-format (delim)
    "Convert table delimited by DELIM (usually copy-pasted from Excel)
to the LaTeX table."
    (interactive "sEnter delimiter (TAB by default): ")
    (when (string= delim "")
        (setq delim "\t"))
    (save-excursion
        (save-restriction
            (my/region-or-env-or-paragraph)
            (my/point-add-one-char (region-end))
            (narrow-to-region
             (region-beginning)
             (my/region-expand-one-char))
            (goto-char (point-min))
            (while (search-forward-regexp delim nil t)
                (replace-match " & " nil nil))
            (goto-char (point-min))
            (while (search-forward-regexp "\n" nil t)
                (replace-match " \\\\\\\\\n" nil nil)))))
#+end_src

А вторая выравнивает таблицу по =&= и =\\=. И заменяет логотипы Emacs обратно на амперсанды.

#+begin_src emacs-lisp
(defun auctex/table-align ()
    "Align LaTeX table by its inner delimeters."
    (interactive)
    (save-excursion
        (save-restriction
            (my/region-or-env-or-paragraph)
            (my/point-add-one-char (region-end))
            (narrow-to-region
             (region-beginning)
             (my/region-expand-one-char))
            (my/protect-inner-amps)
            (goto-char (point-min))
            (while (search-forward-regexp "^&[ ]*" nil t)
                (replace-match " & " nil nil))
            (goto-char (point-min))
            (while (search-forward-regexp "[ ]*&[ ]*" nil t)
                (replace-match " & " nil nil))
            (align-regexp (point-min) (point-max) "\\(\\s-*\\)[^\\]&"
                          1 1 t)
            (align-regexp (point-min) (point-max) "\\(\\s-*\\)\\\\\\\\"
                          1 1 t)
            (goto-char (point-min))
            (my/unprotect-inner-amps))))
#+end_src

#+begin_src emacs-lisp
(use-package company-reftex
    :straight t)
(use-package company-auctex
    :straight t)
(use-package company-math
    :straight t)

(use-package LaTeX
    :straight auctex
    :hook ((LaTeX-mode . lsp/lsp)
           (LaTeX-mode . auctex/extra-commands)
           (LaTeX-mode . turn-on-reftex))
    :config
    (with-eval-after-load 'reftex
        (add-to-list 'reftex-section-levels
                     '("frametitle" . -2))
        (add-to-list 'reftex-section-levels
                     '("framesubtitle" . -3)))
    :custom
    (preview-pdf-color-adjust-method t)
    (preview-auto-cache-preamble t)
    (bibtex-dialect 'biblatex)
    (reftex-cite-format '((?\C-m . "\\cite[]{%l}")
                          (?a . "\\autocite[]{%l}")
                          (?p . "\\parencite[]{%l}")
                          (?f . "\\footcite[][]{%l}")
                          (?t . "\\textcite[]{%l}")
                          (?o . "\\citepr[]{%l}")
                          (?F . "\\fullcite[]{%l}")
                          (?n . "\\nocite{%l}")))
    (reftex-cite-prompt-optional-args t)
    (LaTeX-reftex-cite-format-auto-activate nil)
    (reftex-plug-into-AUCTeX t))
#+end_src
